<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

<span id='global-property-'>/**
</span> * @requires OpenLayers/Control.js
 * @requires OpenLayers/Handler/Drag.js
 * @requires OpenLayers/Handler/Keyboard.js
 */

// NOTE: Overriding OpenLayers.Control.ModifyFeature with code from https://github.com/openlayers/openlayers/pull/1145.
// This override should be removed when possible.

// need this empty Ext JS class definition to make Ext JS class loader happy
Ext.define('OpenEMap.OpenLayers.Control.ModifyFeature', { });

<span id='OpenLayers-Control-ModifyFeature'>/**
</span> * Class: OpenLayers.Control.ModifyFeature
 * Control to modify features.  When activated, a click renders the vertices
 *     of a feature - these vertices can then be dragged.  By default, the
 *     delete key will delete the vertex under the mouse.  New features are
 *     added by dragging &quot;virtual vertices&quot; between vertices.  Create a new
 *     control with the &lt;OpenLayers.Control.ModifyFeature&gt; constructor.
 *
 * Inherits From:
 *  - &lt;OpenLayers.Control&gt;
 */
OpenLayers.Control.ModifyFeature = OpenLayers.Class(OpenLayers.Control, {

<span id='OpenLayers-Control-ModifyFeature-property-bySegment'>    /**
</span>     * APIProperty: bySegment
     * {Boolean} If set to true, one segment at a time will be editable (the
     *     one under the mouse cursor on hover). This supports editing much
     *     larger geometries. This requires the rbush library
     *     (https://github.com/mourner/rbush) for spatial indexing. Default is
     *     false.
     */
    bySegment: false,

<span id='OpenLayers-Control-ModifyFeature-property-documentDrag'>    /**
</span>     * APIProperty: documentDrag
     * {Boolean} If set to true, dragging vertices will continue even if the
     *     mouse cursor leaves the map viewport. Default is false.
     */
    documentDrag: false,

<span id='OpenLayers-Control-ModifyFeature-property-geometryTypes'>    /**
</span>     * APIProperty: geometryTypes
     * {Array(String)} To restrict modification to a limited set of geometry
     *     types, send a list of strings corresponding to the geometry class
     *     names.
     */
    geometryTypes: null,

<span id='OpenLayers-Control-ModifyFeature-property-clickout'>    /**
</span>     * APIProperty: clickout
     * {Boolean} Unselect features when clicking outside any feature.
     *     Default is true.
     */
    clickout: true,

<span id='OpenLayers-Control-ModifyFeature-property-toggle'>    /**
</span>     * APIProperty: toggle
     * {Boolean} Unselect a selected feature on click.
     *      Default is true.
     */
    toggle: true,

<span id='OpenLayers-Control-ModifyFeature-property-standalone'>    /**
</span>     * APIProperty: standalone
     * {Boolean} Set to true to create a control without SelectFeature
     *     capabilities. Default is false.  If standalone is true, to modify
     *     a feature, call the &lt;selectFeature&gt; method with the target feature.
     *     Note that you must call the &lt;unselectFeature&gt; method to finish
     *     feature modification in standalone mode (before starting to modify
     *     another feature).
     */
    standalone: false,

<span id='OpenLayers-Control-ModifyFeature-property-layer'>    /**
</span>     * Property: layer
     * {&lt;OpenLayers.Layer.Vector&gt;}
     */
    layer: null,

<span id='OpenLayers-Control-ModifyFeature-property-feature'>    /**
</span>     * Property: feature
     * {&lt;OpenLayers.Feature.Vector&gt;} Feature currently available for modification.
     */
    feature: null,

<span id='OpenLayers-Control-ModifyFeature-property-vertex'>    /**
</span>     * Property: vertex
     * {&lt;OpenLayers.Feature.Vector&gt;} Vertex currently being modified.
     */
    vertex: null,

<span id='OpenLayers-Control-ModifyFeature-property-vertices'>    /**
</span>     * Property: vertices
     * {Array(&lt;OpenLayers.Feature.Vector&gt;)} Verticies currently available
     *     for dragging.
     */
    vertices: null,

<span id='OpenLayers-Control-ModifyFeature-property-virtualVertices'>    /**
</span>     * Property: virtualVertices
     * {Array(&lt;OpenLayers.Feature.Vector&gt;)} Virtual vertices in the middle
     *     of each edge.
     */
    virtualVertices: null,

<span id='OpenLayers-Control-ModifyFeature-property-handlers'>    /**
</span>     * Property: handlers
     * {Object}
     */
    handlers: null,

<span id='OpenLayers-Control-ModifyFeature-property-deleteCodes'>    /**
</span>     * APIProperty: deleteCodes
     * {Array(Integer)} Keycodes for deleting verticies.  Set to null to disable
     *     vertex deltion by keypress.  If non-null, keypresses with codes
     *     in this array will delete vertices under the mouse. Default
     *     is 46 and 68, the 'delete' and lowercase 'd' keys.
     */
    deleteCodes: null,

<span id='OpenLayers-Control-ModifyFeature-property-virtualStyle'>    /**
</span>     * APIProperty: virtualStyle
     * {Object} A symbolizer to be used for virtual vertices.
     */
    virtualStyle: null,
    
<span id='OpenLayers-Control-ModifyFeature-property-dragHandleStyle'>    /**
</span>     * APIProperty: dragHandleStyle
     * {Object} A symbolizer to be used for drag handles.
     */
    dragHandleStyle: null,
    
<span id='OpenLayers-Control-ModifyFeature-property-radiusHandleStyle'>    /**
</span>     * APIProperty: dragHandleStyle
     * {Object} A symbolizer to be used for radius handles.
     */
    radiusHandleStyle: null,

<span id='OpenLayers-Control-ModifyFeature-property-vertexRenderIntent'>    /**
</span>     * APIProperty: vertexRenderIntent
     * {String} The renderIntent to use for vertices. If no &lt;virtualStyle&gt; is
     * provided, this renderIntent will also be used for virtual vertices, with
     * a fillOpacity and strokeOpacity of 0.3. Default is null, which means
     * that the layer's default style will be used for vertices.
     */
    vertexRenderIntent: null,

<span id='OpenLayers-Control-ModifyFeature-property-mode'>    /**
</span>     * APIProperty: mode
     * {Integer} Bitfields specifying the modification mode. Defaults to
     *      OpenLayers.Control.ModifyFeature.RESHAPE. To set the mode to a
     *      combination of options, use the | operator. For example, to allow
     *      the control to both resize and rotate features, use the following
     *      syntax
     * (code)
     * control.mode = OpenLayers.Control.ModifyFeature.RESIZE |
     *                OpenLayers.Control.ModifyFeature.ROTATE;
     *  (end)
     */
    mode: null,

<span id='OpenLayers-Control-ModifyFeature-property-createVertices'>    /**
</span>     * APIProperty: createVertices
     * {Boolean} Create new vertices by dragging the virtual vertices
     *     in the middle of each edge. Default is true.
     */
    createVertices: true,

<span id='OpenLayers-Control-ModifyFeature-property-modified'>    /**
</span>     * Property: modified
     * {Boolean} The currently selected feature has been modified.
     */
    modified: false,

<span id='OpenLayers-Control-ModifyFeature-property-radiusHandle'>    /**
</span>     * Property: radiusHandle
     * {&lt;OpenLayers.Feature.Vector&gt;} A handle for rotating/resizing a feature.
     */
    radiusHandle: null,

<span id='OpenLayers-Control-ModifyFeature-property-dragHandle'>    /**
</span>     * Property: dragHandle
     * {&lt;OpenLayers.Feature.Vector&gt;} A handle for dragging a feature.
     */
    dragHandle: null,

<span id='OpenLayers-Control-ModifyFeature-method-onModificationStart'>    /**
</span>     * APIProperty: onModificationStart 
     * {Function} *Deprecated*.  Register for &quot;beforefeaturemodified&quot; instead.
     *     The &quot;beforefeaturemodified&quot; event is triggered on the layer before
     *     any modification begins.
     *
     * Optional function to be called when a feature is selected
     *     to be modified. The function should expect to be called with a
     *     feature.  This could be used for example to allow to lock the
     *     feature on server-side.
     */
    onModificationStart: function() {},

<span id='OpenLayers-Control-ModifyFeature-method-onModification'>    /**
</span>     * APIProperty: onModification
     * {Function} *Deprecated*.  Register for &quot;featuremodified&quot; instead.
     *     The &quot;featuremodified&quot; event is triggered on the layer with each
     *     feature modification.
     *
     * Optional function to be called when a feature has been
     *     modified.  The function should expect to be called with a feature.
     */
    onModification: function() {},

<span id='OpenLayers-Control-ModifyFeature-method-onModificationEnd'>    /**
</span>     * APIProperty: onModificationEnd
     * {Function} *Deprecated*.  Register for &quot;afterfeaturemodified&quot; instead.
     *     The &quot;afterfeaturemodified&quot; event is triggered on the layer after
     *     a feature has been modified.
     *
     * Optional function to be called when a feature is finished 
     *     being modified.  The function should expect to be called with a
     *     feature.
     */
    onModificationEnd: function() {},

<span id='OpenLayers-Control-ModifyFeature-method-initialize'>    /**
</span>     * Constructor: OpenLayers.Control.ModifyFeature
     * Create a new modify feature control.
     *
     * Parameters:
     * layer - {&lt;OpenLayers.Layer.Vector&gt;} Layer that contains features that
     *     will be modified.
     * options - {Object} Optional object whose properties will be set on the
     *     control.
     */
    initialize: function(layer, options) {
        options = options || {};
        this.layer = layer;
        this.vertices = [];
        this.virtualVertices = [];
        this.virtualStyle = OpenLayers.Util.extend({},
            this.layer.style ||
            this.layer.styleMap.createSymbolizer(null, options.vertexRenderIntent)
        );
        this.virtualStyle.fillOpacity = 0.3;
        this.virtualStyle.strokeOpacity = 0.3;
        this.deleteCodes = [46, 68];
        this.mode = OpenLayers.Control.ModifyFeature.RESHAPE;
        OpenLayers.Control.prototype.initialize.apply(this, [options]);
        if(!(OpenLayers.Util.isArray(this.deleteCodes))) {
            this.deleteCodes = [this.deleteCodes];
        }
        
        // configure the drag handler
        var dragCallbacks = {
            down: function(pixel) {
                this.vertex = null;
                var feature = this.layer.getFeatureFromEvent(
                        this.handlers.drag.evt);
                if (feature) {
                    this.dragStart(feature);
                } else if (this.clickout) {
                    this._unselect = this.feature;
                }
            },
            move: function(pixel) {
                delete this._unselect;
                if (this.vertex) {
                    this.dragVertex(this.vertex, pixel);
                }
            },
            up: function() {
                this.handlers.drag.stopDown = false;
                if (this._unselect) {
                    this.unselectFeature(this._unselect);
                    delete this._unselect;
                }
            },
            done: function(pixel) {
                if (this.vertex) {
                    this.dragComplete(this.vertex);
                }
            }
        };
        var _self = this;
        var dragOptions = {
            documentDrag: this.documentDrag,
            setEvent: function(evt) {
                var feature = _self.feature;
                _self._lastVertex = feature ?
                                  feature.layer.getFeatureFromEvent(evt) : null;
                OpenLayers.Handler.Drag.prototype.setEvent.apply(
                                                               this, arguments);
            },
            stopDown: false
        };

        // configure the keyboard handler
        var keyboardOptions = {
            keydown: this.handleKeypress
        };
        this.handlers = {
            keyboard: new OpenLayers.Handler.Keyboard(this, keyboardOptions),
            drag: new OpenLayers.Handler.Drag(this, dragCallbacks, dragOptions)
        };

        if (this.bySegment) {
            if (!window.rbush) {
                throw new Error(&quot;The rbush library is required&quot;);
            }
            if (!OpenLayers.Control.ModifyFeature.BySegment) {
                throw new Error(&quot;OpenLayers.Control.ModifyFeature.BySegment is missing from the build&quot;);
            } else {
                OpenLayers.Util.extend(this, OpenLayers.Control.ModifyFeature.BySegment);
            }
        }
    },

<span id='OpenLayers-Control-ModifyFeature-method-createVirtualVertex'>    /**
</span>     * Method: createVirtualVertex
     * Create a virtual vertex in the middle of the segment.
     *
     * Parameters:
     * point1 - {&lt;OpenLayers.Geometry.Point&gt;} First point of the segment.
     * point2 - {&lt;OpenLayers.Geometry.Point&gt;} Second point of the segment.
     *
     * Returns:
     * {&lt;OpenLayers.Feature.Vector&gt;} The virtual vertex created.
     */
    createVirtualVertex: function(point1, point2) {
        var x = (point1.x + point2.x) / 2;
        var y = (point1.y + point2.y) / 2;
        var point = new OpenLayers.Feature.Vector(
            new OpenLayers.Geometry.Point(x, y),
            null, this.virtualStyle
        );
        point._sketch = true;
        return point;
    },

<span id='OpenLayers-Control-ModifyFeature-method-destroy'>    /**
</span>     * APIMethod: destroy
     * Take care of things that are not handled in superclass.
     */
    destroy: function() {
        if (this.map) {
            this.map.events.un({
                &quot;removelayer&quot;: this.handleMapEvents,
                &quot;changelayer&quot;: this.handleMapEvents,
                scope: this
            });
        }
        this.layer = null;
        OpenLayers.Control.prototype.destroy.apply(this, []);
    },

<span id='OpenLayers-Control-ModifyFeature-method-activate'>    /**
</span>     * APIMethod: activate
     * Activate the control.
     * 
     * Returns:
     * {Boolean} Successfully activated the control.
     */
    activate: function() {
        if (OpenLayers.Control.prototype.activate.apply(this, arguments)) {
            this.moveLayerToTop();
            this.map.events.on({
                &quot;removelayer&quot;: this.handleMapEvents,
                &quot;changelayer&quot;: this.handleMapEvents,
                scope: this
            });
            this._lastVertex = null;
            return this.handlers.keyboard.activate() &amp;&amp;
                    this.handlers.drag.activate();
        }
        return false;
    },

<span id='OpenLayers-Control-ModifyFeature-method-deactivate'>    /**
</span>     * APIMethod: deactivate
     * Deactivate the control.
     *
     * Returns: 
     * {Boolean} Successfully deactivated the control.
     */
    deactivate: function() {
        var deactivated = false;
        // the return from the controls is unimportant in this case
        if(OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {
            this.moveLayerBack();
            this.map.events.un({
                &quot;removelayer&quot;: this.handleMapEvents,
                &quot;changelayer&quot;: this.handleMapEvents,
                scope: this
            });
            this.layer.removeFeatures(this.vertices, {silent: true});
            this.layer.removeFeatures(this.virtualVertices, {silent: true});
            this.vertices = [];
            this.handlers.drag.deactivate();
            this.handlers.keyboard.deactivate();
            var feature = this.feature;
            if (feature &amp;&amp; feature.geometry &amp;&amp; feature.layer) {
                this.unselectFeature(feature);
            }
            deactivated = true;
        }
        return deactivated;
    },

<span id='OpenLayers-Control-ModifyFeature-method-beforeSelectFeature'>    /**
</span>     * Method: beforeSelectFeature
     * Called before a feature is selected.
     *
     * Parameters:
     * feature - {&lt;OpenLayers.Feature.Vector&gt;} The feature about to be selected.
     */
    beforeSelectFeature: function(feature) {
        return this.layer.events.triggerEvent(
            &quot;beforefeaturemodified&quot;, {feature: feature}
        );
    },

<span id='OpenLayers-Control-ModifyFeature-method-selectFeature'>    /**
</span>     * APIMethod: selectFeature
     * Select a feature for modification in standalone mode. In non-standalone
     * mode, this method is called when a feature is selected by clicking.
     * Register a listener to the beforefeaturemodified event and return false
     * to prevent feature modification.
     *
     * Parameters:
     * feature - {&lt;OpenLayers.Feature.Vector&gt;} the selected feature.
     */
    selectFeature: function(feature) {
        if (this.feature === feature ||
           (this.geometryTypes &amp;&amp; OpenLayers.Util.indexOf(this.geometryTypes,
           feature.geometry.CLASS_NAME) == -1)) {
            return;
        }
        if (this.beforeSelectFeature(feature) !== false) {
            if (this.feature) {
                this.unselectFeature(this.feature);
            }
            this.feature = feature;
            this.layer.selectedFeatures.push(feature);
            this.layer.drawFeature(feature, 'select');
            this.modified = false;
            this.resetVertices();
            this.onModificationStart(this.feature);
        }
        // keep track of geometry modifications
        var modified = feature.modified;
        if (feature.geometry &amp;&amp; !(modified &amp;&amp; modified.geometry)) {
            this._originalGeometry = feature.geometry.clone();
        }
    },

<span id='OpenLayers-Control-ModifyFeature-method-unselectFeature'>    /**
</span>     * APIMethod: unselectFeature
     * Called when the select feature control unselects a feature.
     *
     * Parameters:
     * feature - {&lt;OpenLayers.Feature.Vector&gt;} The unselected feature.
     */
    unselectFeature: function(feature) {
        this.layer.removeFeatures(this.vertices, {silent: true});
        this.vertices = [];
        this.layer.destroyFeatures(this.virtualVertices, {silent: true});
        this.virtualVertices = [];
        if(this.dragHandle) {
            this.layer.destroyFeatures([this.dragHandle], {silent: true});
            delete this.dragHandle;
        }
        if(this.radiusHandle) {
            this.layer.destroyFeatures([this.radiusHandle], {silent: true});
            delete this.radiusHandle;
        }
        this.layer.drawFeature(this.feature, 'default');
        this.feature = null;
        OpenLayers.Util.removeItem(this.layer.selectedFeatures, feature);
        this.onModificationEnd(feature);
        this.layer.events.triggerEvent(&quot;afterfeaturemodified&quot;, {
            feature: feature,
            modified: this.modified
        });
        this.modified = false;
    },
    
    
<span id='OpenLayers-Control-ModifyFeature-method-dragStart'>    /**
</span>     * Method: dragStart
     * Called by the drag handler before a feature is dragged.  This method is
     *     used to differentiate between points and vertices
     *     of higher order geometries.
     *
     * Parameters:
     * feature - {&lt;OpenLayers.Feature.Vector&gt;} The point or vertex about to be
     *     dragged.
     */
    dragStart: function(feature) {
        var isPoint = feature.geometry.CLASS_NAME ==
                'OpenLayers.Geometry.Point';
        if (!this.standalone &amp;&amp;
                ((!feature._sketch &amp;&amp; isPoint) || !feature._sketch)) {
            if (this.toggle &amp;&amp; this.feature === feature) {
                // mark feature for unselection
                this._unselect = feature;
            }
            this.selectFeature(feature);
        }
        if (this.feature &amp;&amp;
                (feature._sketch || isPoint &amp;&amp; feature === this.feature)) {
            // feature is a drag or virtual handle or point
            this.vertex = feature;
            this.handlers.drag.stopDown = true;
        }
    },

<span id='OpenLayers-Control-ModifyFeature-method-dragVertex'>    /**
</span>     * Method: dragVertex
     * Called by the drag handler with each drag move of a vertex.
     *
     * Parameters:
     * vertex - {&lt;OpenLayers.Feature.Vector&gt;} The vertex being dragged.
     * pixel - {&lt;OpenLayers.Pixel&gt;} Pixel location of the mouse event.
     */
    dragVertex: function(vertex, pixel) {
        var pos = this.map.getLonLatFromViewPortPx(pixel);
        var geom = vertex.geometry;
        geom.move(pos.lon - geom.x, pos.lat - geom.y);
        this.modified = true;
<span id='OpenLayers-Control-ModifyFeature-property-'>        /**
</span>         * Five cases:
         * 1) dragging a simple point
         * 2) dragging a virtual vertex
         * 3) dragging a drag handle
         * 4) dragging a real vertex
         * 5) dragging a radius handle
         */
        if(this.feature.geometry.CLASS_NAME == &quot;OpenLayers.Geometry.Point&quot;) {
            // dragging a simple point
            this.layer.events.triggerEvent(&quot;vertexmodified&quot;, {
                vertex: vertex.geometry,
                feature: this.feature,
                pixel: pixel
            });
        } else {
            if(vertex._index) {
                if (vertex._index == -1) {
                    vertex._index = OpenLayers.Util.indexOf(vertex.geometry.parent.components, vertex._next);
                }
                // dragging a virtual vertex
                vertex.geometry.parent.addComponent(vertex.geometry,
                                                    vertex._index);
                // move from virtual to real vertex
                delete vertex._index;
                OpenLayers.Util.removeItem(this.virtualVertices, vertex);
                this.vertices.push(vertex);
            } else if(vertex == this.dragHandle) {
                // dragging a drag handle
                this.layer.removeFeatures(this.vertices, {silent: true});
                this.vertices = [];
                if(this.radiusHandle) {
                    this.layer.destroyFeatures([this.radiusHandle], {silent: true});
                    this.radiusHandle = null;
                }
            } else if(vertex !== this.radiusHandle) {
                // dragging a real vertex
                this.layer.events.triggerEvent(&quot;vertexmodified&quot;, {
                    vertex: vertex.geometry,
                    feature: this.feature,
                    pixel: pixel
                });
            }
            // dragging a radius handle - no special treatment
            if(this.virtualVertices.length &gt; 0) {
                this.layer.destroyFeatures(this.virtualVertices, {silent: true});
                this.virtualVertices = [];
            }
            this.layer.drawFeature(this.feature, this.standalone ? undefined :
                                            'select');
        }
        // keep the vertex on top so it gets the mouseout after dragging
        // this should be removed in favor of an option to draw under or
        // maintain node z-index
        this.layer.drawFeature(vertex);
    },

<span id='OpenLayers-Control-ModifyFeature-method-dragComplete'>    /**
</span>     * Method: dragComplete
     * Called by the drag handler when the feature dragging is complete.
     *
     * Parameters:
     * vertex - {&lt;OpenLayers.Feature.Vector&gt;} The vertex being dragged.
     */
    dragComplete: function(vertex) {
        this.resetVertices();
        this.setFeatureState();
        this.onModification(this.feature);
        this.layer.events.triggerEvent(&quot;featuremodified&quot;, {feature: this.feature});
    },
    
<span id='OpenLayers-Control-ModifyFeature-method-setFeatureState'>    /**
</span>     * Method: setFeatureState
     * Called when the feature is modified.  If the current state is not
     *     INSERT or DELETE, the state is set to UPDATE.
     */
    setFeatureState: function() {
        if(this.feature.state != OpenLayers.State.INSERT &amp;&amp;
           this.feature.state != OpenLayers.State.DELETE) {
            this.feature.state = OpenLayers.State.UPDATE;
            if (this.modified &amp;&amp; this._originalGeometry) {
                var feature = this.feature;
                feature.modified = OpenLayers.Util.extend(feature.modified, {
                    geometry: this._originalGeometry
                });
                delete this._originalGeometry;
            }
        }
    },
    
<span id='OpenLayers-Control-ModifyFeature-method-resetVertices'>    /**
</span>     * Method: resetVertices
     */
    resetVertices: function() {
        if(this.vertices.length &gt; 0) {
            this.layer.removeFeatures(this.vertices, {silent: true});
            this.vertices = [];
        }
        if(this.virtualVertices.length &gt; 0) {
            this.layer.removeFeatures(this.virtualVertices, {silent: true});
            this.virtualVertices = [];
        }
        if(this.dragHandle) {
            this.layer.destroyFeatures([this.dragHandle], {silent: true});
            this.dragHandle = null;
        }
        if(this.radiusHandle) {
            this.layer.destroyFeatures([this.radiusHandle], {silent: true});
            this.radiusHandle = null;
        }
        if(this.feature &amp;&amp;
           this.feature.geometry.CLASS_NAME != &quot;OpenLayers.Geometry.Point&quot;) {
            if((this.mode &amp; OpenLayers.Control.ModifyFeature.DRAG)) {
                this.collectDragHandle();
            }
            if((this.mode &amp; (OpenLayers.Control.ModifyFeature.ROTATE |
                             OpenLayers.Control.ModifyFeature.RESIZE))) {
                this.collectRadiusHandle();
            }
            if(this.mode &amp; OpenLayers.Control.ModifyFeature.RESHAPE){
                // Don't collect vertices when we're resizing
                if (!(this.mode &amp; OpenLayers.Control.ModifyFeature.RESIZE)){
                    this.collectVertices();
                }
            }
        }
    },
    
<span id='OpenLayers-Control-ModifyFeature-method-handleKeypress'>    /**
</span>     * Method: handleKeypress
     * Called by the feature handler on keypress.  This is used to delete
     *     vertices. If the &lt;deleteCode&gt; property is set, vertices will
     *     be deleted when a feature is selected for modification and
     *     the mouse is over a vertex.
     *
     * Parameters:
     * evt - {Event} Keypress event.
     */
    handleKeypress: function(evt) {
        var code = evt.keyCode;
        
        // check for delete key
        if(this.feature &amp;&amp;
           OpenLayers.Util.indexOf(this.deleteCodes, code) != -1) {
            var vertex = this._lastVertex;
            if (vertex &amp;&amp;
                    OpenLayers.Util.indexOf(this.vertices, vertex) != -1 &amp;&amp;
                    !this.handlers.drag.dragging &amp;&amp; vertex.geometry.parent) {
                // remove the vertex
                vertex.geometry.parent.removeComponent(vertex.geometry);
                this.layer.events.triggerEvent(&quot;vertexremoved&quot;, {
                    vertex: vertex.geometry,
                    feature: this.feature,
                    pixel: evt.xy
                });
                this.layer.drawFeature(this.feature, this.standalone ?
                                       undefined : 'select');
                this.modified = true;
                this.resetVertices();
                this.setFeatureState();
                this.onModification(this.feature);
                this.layer.events.triggerEvent(&quot;featuremodified&quot;,
                                               {feature: this.feature});
            }
        }
    },

<span id='OpenLayers-Control-ModifyFeature-method-collectVertices'>    /**
</span>     * Method: collectVertices
     * Collect the vertices from the modifiable feature's geometry and push
     *     them on to the control's vertices array.
     */
    collectVertices: function() {
        this.vertices = [];
        this.virtualVertices = [];
        var control = this;
        function collectComponentVertices(geometry) {
            var i, vertex, component, len;
            if(geometry.CLASS_NAME == &quot;OpenLayers.Geometry.Point&quot;) {
                vertex = new OpenLayers.Feature.Vector(geometry);
                vertex._sketch = true;
                vertex.renderIntent = control.vertexRenderIntent;
                control.vertices.push(vertex);
            } else {
                var numVert = geometry.components.length;
                if(geometry.CLASS_NAME == &quot;OpenLayers.Geometry.LinearRing&quot;) {
                    numVert -= 1;
                }
                for(i=0; i&lt;numVert; ++i) {
                    component = geometry.components[i];
                    if(component.CLASS_NAME == &quot;OpenLayers.Geometry.Point&quot;) {
                        vertex = new OpenLayers.Feature.Vector(component);
                        vertex._sketch = true;
                        vertex.renderIntent = control.vertexRenderIntent;
                        control.vertices.push(vertex);
                    } else {
                        collectComponentVertices(component);
                    }
                }
                
                // add virtual vertices in the middle of each edge
                if (control.createVertices &amp;&amp; geometry.CLASS_NAME != &quot;OpenLayers.Geometry.MultiPoint&quot;) {
                    for(i=0, len=geometry.components.length; i&lt;len-1; ++i) {
                        var prevVertex = geometry.components[i];
                        var nextVertex = geometry.components[i + 1];
                        if(prevVertex.CLASS_NAME == &quot;OpenLayers.Geometry.Point&quot; &amp;&amp;
                           nextVertex.CLASS_NAME == &quot;OpenLayers.Geometry.Point&quot;) {
                            var point = control.createVirtualVertex.call(control, prevVertex, nextVertex);
                            // set the virtual parent and intended index
                            point.geometry.parent = geometry;
                            point._index = i + 1;
                            control.virtualVertices.push(point);
                        }
                    }
                }
            }
        }
        collectComponentVertices.call(this, this.feature.geometry);
        this.layer.addFeatures(this.virtualVertices, {silent: true});
        this.layer.addFeatures(this.vertices, {silent: true});
    },

<span id='OpenLayers-Control-ModifyFeature-method-collectDragHandle'>    /**
</span>     * Method: collectDragHandle
     * Collect the drag handle for the selected geometry.
     */
    collectDragHandle: function() {
        var geometry = this.feature.geometry;
        var center = geometry.getBounds().getCenterLonLat();
        var originGeometry = new OpenLayers.Geometry.Point(
            center.lon, center.lat
        );
        var origin = new OpenLayers.Feature.Vector(originGeometry, null, this.dragHandleStyle);
        originGeometry.move = function(x, y) {
            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);
            geometry.move(x, y);
        };
        origin._sketch = true;
        this.dragHandle = origin;
        this.dragHandle.renderIntent = this.vertexRenderIntent;
        this.layer.addFeatures([this.dragHandle], {silent: true});
    },

<span id='OpenLayers-Control-ModifyFeature-method-collectRadiusHandle'>    /**
</span>     * Method: collectRadiusHandle
     * Collect the radius handle for the selected geometry.
     */
    collectRadiusHandle: function() {
        var geometry = this.feature.geometry;
        var bounds = geometry.getBounds();
        var center = bounds.getCenterLonLat();
        var originGeometry = new OpenLayers.Geometry.Point(
            center.lon, center.lat
        );
        var radiusGeometry = new OpenLayers.Geometry.Point(
            bounds.right, bounds.bottom
        );
        var radius = new OpenLayers.Feature.Vector(radiusGeometry, null, this.radiusHandleStyle);
        var resize = (this.mode &amp; OpenLayers.Control.ModifyFeature.RESIZE);
        var reshape = (this.mode &amp; OpenLayers.Control.ModifyFeature.RESHAPE);
        var rotate = (this.mode &amp; OpenLayers.Control.ModifyFeature.ROTATE);

        radiusGeometry.move = function(x, y) {
            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);
            var dx1 = this.x - originGeometry.x;
            var dy1 = this.y - originGeometry.y;
            var dx0 = dx1 - x;
            var dy0 = dy1 - y;
            if(rotate) {
                var a0 = Math.atan2(dy0, dx0);
                var a1 = Math.atan2(dy1, dx1);
                var angle = a1 - a0;
                angle *= 180 / Math.PI;
                geometry.rotate(angle, originGeometry);
            }
            if(resize) {
                var scale, ratio;
                // 'resize' together with 'reshape' implies that the aspect 
                // ratio of the geometry will not be preserved whilst resizing 
                if (reshape) {
                    scale = dy1 / dy0;
                    ratio = (dx1 / dx0) / scale;
                } else {
                    var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));
                    var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));
                    scale = l1 / l0;
                }
                geometry.resize(scale, originGeometry, ratio);
            }
        };
        radius._sketch = true;
        this.radiusHandle = radius;
        this.radiusHandle.renderIntent = this.vertexRenderIntent;
        this.layer.addFeatures([this.radiusHandle], {silent: true});
    },

<span id='OpenLayers-Control-ModifyFeature-method-setMap'>    /**
</span>     * Method: setMap
     * Set the map property for the control and all handlers.
     *
     * Parameters:
     * map - {&lt;OpenLayers.Map&gt;} The control's map.
     */
    setMap: function(map) {
        this.handlers.drag.setMap(map);
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
    },

<span id='OpenLayers-Control-ModifyFeature-method-handleMapEvents'>    /**
</span>     * Method: handleMapEvents
     * 
     * Parameters:
     * evt - {Object}
     */
    handleMapEvents: function(evt) {
        if (evt.type == &quot;removelayer&quot; || evt.property == &quot;order&quot;) {
            this.moveLayerToTop();
        }
    },

<span id='OpenLayers-Control-ModifyFeature-method-moveLayerToTop'>    /**
</span>     * Method: moveLayerToTop
     * Moves the layer for this handler to the top, so mouse events can reach
     * it.
     */
    moveLayerToTop: function() {
        var index = Math.max(this.map.Z_INDEX_BASE['Feature'] - 1,
            this.layer.getZIndex()) + 1;
        this.layer.setZIndex(index);
        
    },

<span id='OpenLayers-Control-ModifyFeature-method-moveLayerBack'>    /**
</span>     * Method: moveLayerBack
     * Moves the layer back to the position determined by the map's layers
     * array.
     */
    moveLayerBack: function() {
        var index = this.layer.getZIndex() - 1;
        if (index &gt;= this.map.Z_INDEX_BASE['Feature']) {
            this.layer.setZIndex(index);
        } else {
            this.map.setLayerZIndex(this.layer,
                this.map.getLayerIndex(this.layer));
        }
    },

    CLASS_NAME: &quot;OpenLayers.Control.ModifyFeature&quot;
});

<span id='OpenLayers-Control-ModifyFeature-RESHAPE'>/**
</span> * Constant: RESHAPE
 * {Integer} Constant used to make the control work in reshape mode
 */
OpenLayers.Control.ModifyFeature.RESHAPE = 1;
<span id='OpenLayers-Control-ModifyFeature-RESIZE'>/**
</span> * Constant: RESIZE
 * {Integer} Constant used to make the control work in resize mode
 */
OpenLayers.Control.ModifyFeature.RESIZE = 2;
<span id='OpenLayers-Control-ModifyFeature-ROTATE'>/**
</span> * Constant: ROTATE
 * {Integer} Constant used to make the control work in rotate mode
 */
OpenLayers.Control.ModifyFeature.ROTATE = 4;
<span id='OpenLayers-Control-ModifyFeature-DRAG'>/**
</span> * Constant: DRAG
 * {Integer} Constant used to make the control work in drag mode
 */
OpenLayers.Control.ModifyFeature.DRAG = 8;</pre>
</body>
</html>
