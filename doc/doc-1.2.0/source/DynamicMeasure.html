<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright 2011-2014 Xavier Mamano, http://github.com/jorix/OL-DynamicMeasure
 * Published under MIT license. */

<span id='global-property-'>/**
</span> * @requires OpenLayers/Control/Measure.js
 * @requires OpenLayers/Rule.js
 * @requires OpenLayers/StyleMap.js
 */

// need this empty Ext JS class definition to make Ext JS class loader happy
Ext.define('OpenEMap.OpenLayers.Control.DynamicMeasure', { });

<span id='OpenLayers-Control-DynamicMeasure'>/**
</span> * Class: OpenLayers.Control.DynamicMeasure
 * Allows for drawing of features for measurements.
 *
 * Inherits from:
 *  - &lt;OpenLayers.Control.Measure&gt;
 */
OpenLayers.Control.DynamicMeasure = OpenLayers.Class(
		OpenLayers.Control.Measure, {

<span id='OpenLayers-Control-DynamicMeasure-property-accuracy'>    /**
</span>     * APIProperty: accuracy
     * {Integer} Digits measurement accuracy, default is 5.
     */
    accuracy: 5,

<span id='OpenLayers-Control-DynamicMeasure-property-persist'>    /**
</span>     * APIProperty: persist
     * {Boolean} Keep the temporary measurement after the
     *     measurement is complete.  The measurement will persist until a new
     *     measurement is started, the control is deactivated, or &lt;cancel&gt; is
     *     called. Default is true.
     */
    persist: false,

<span id='OpenLayers-Control-DynamicMeasure-property-styles'>    /**
</span>     * APIProperty: styles
     * {Object} Alterations of the default styles of the points lines poligons
     *     and labels text, could use keys: &quot;Point&quot;, &quot;Line&quot;,
     *     &quot;Polygon&quot;, &quot;labelSegments&quot;, &quot;labelHeading&quot;, &quot;labelLength&quot; and
     *     &quot;labelArea&quot;. Default is &lt;OpenLayers.Control.DynamicMeasure.styles&gt;.
     */
    styles: null,

<span id='OpenLayers-Control-DynamicMeasure-property-positions'>    /**
</span>     * APIProperty: positions
     * {Object} Alterations of the default position of the labels, could use
     *     keys: &quot;labelSegments&quot; &amp; &quot;labelHeading&quot;, with values &quot;start&quot; &quot;middle&quot;
     *     and &quot;end&quot; refered of the current segment; and keys: &quot;labelLength&quot; &amp;
     *     &quot;labelArea&quot; with additional values &quot;center&quot; (of the feature) and
     *     &quot;initial&quot; (initial point of the feature) and also mentioned previus
     *     values. Default is
     *     &lt;OpenLayers.Control.DynamicMeasure.positions&gt;.
     */
    positions: null,

<span id='OpenLayers-Control-DynamicMeasure-property-maxSegments'>    /**
</span>     * APIProperty: maxSegments
     * {Integer|Null} Maximum number of visible segments measures, default is 1.
     *
     * To avoid soiling the track is desirable to reduce the number of visible
     *     segments.
     */
    maxSegments: 1,

<span id='OpenLayers-Control-DynamicMeasure-property-maxHeadings'>    /**
</span>     * APIProperty: maxHeadings
     * {Integer|Null} Maximum number of visible headings measures, default is 1.
     *
     * To avoid soiling the track is desirable to reduce the number of visible
     *     segments.
     */
    maxHeadings: 1,

<span id='OpenLayers-Control-DynamicMeasure-property-layerSegmentsOptions'>    /**
</span>     * APIProperty: layerSegmentsOptions
     * {Object} Any optional properties to be set on the
     *     layer of &lt;layerSegments&gt; of the lengths of the segments. If set to
     *     null the layer does not act.
     *
     *     If `styleMap` options is set then the key &quot;labelSegments&quot; of the
     *     `styles` option is ignored.
     */
    layerSegmentsOptions: undefined,

<span id='OpenLayers-Control-DynamicMeasure-property-layerHeadingOptions'>    /**
</span>     * APIProperty: layerHeadingOptions
     * {Object} Any optional properties to be set on the
     *     layer of &lt;layerHeading&gt; of the angle of the segments. If set to
     *     null the layer does not act.  Default is null, set to {} to use a
     *     &lt;layerHeading&gt; to show headings.
     *
     *     If `styleMap` options is set then the key &quot;labelHeading&quot; of the
     *     `styles` option is ignored.
     */
    layerHeadingOptions: null,

<span id='OpenLayers-Control-DynamicMeasure-property-layerLengthOptions'>    /**
</span>     * APIProperty: layerLengthOptions
     * {Object} Any optional properties to be set on the
     *     layer of &lt;layerLength&gt; of the total length. If set to null the layer
     *     does not act.
     *
     *     If `styleMap` option is set then the key &quot;labelLength&quot; of the
     *     `styles` option is ignored.
     */
    layerLengthOptions: undefined,

<span id='OpenLayers-Control-DynamicMeasure-property-layerAreaOptions'>    /**
</span>     * APIProperty: layerAreaOptions
     * {Object} Any optional properties to be set on the
     *     layer of &lt;layerArea&gt; of the total area. If set to null the layer does
     *     not act.
     *
     *     If `styleMap` is set then the key &quot;labelArea&quot; of the `styles` option
     *     is ignored.
     */
    layerAreaOptions: undefined,

<span id='OpenLayers-Control-DynamicMeasure-property-drawingLayer'>    /**
</span>     * APIProperty: drawingLayer
     * {&lt;OpenLayers.Layer.Vector&gt;} Drawing layer to store the drawing when
     *     finished.
     */
    drawingLayer: null,

<span id='OpenLayers-Control-DynamicMeasure-property-multi'>    /**
</span>     * APIProperty: multi
     * {Boolean} Cast features to multi-part geometries before passing to the
     *     drawing layer, only used if declared a &lt;drawingLayer&gt;.
     * Default is false.
     */
    multi: false,

<span id='OpenLayers-Control-DynamicMeasure-property-layerSegments'>    /**
</span>     * Property: layerSegments
     * {&lt;OpenLayers.Layer.Vector&gt;} The temporary drawing layer to show the
     *     length of the segments.
     */
    layerSegments: null,

<span id='OpenLayers-Control-DynamicMeasure-property-layerLength'>    /**
</span>     * Property: layerLength
     * {&lt;OpenLayers.Layer.Vector&gt;} The temporary drawing layer to show total
     *     length.
     */
    layerLength: null,

<span id='OpenLayers-Control-DynamicMeasure-property-layerArea'>    /**
</span>     * Property: layerArea
     * {&lt;OpenLayers.Layer.Vector&gt;} The temporary drawing layer to show total
     *     area.
     */
    layerArea: null,

<span id='OpenLayers-Control-DynamicMeasure-property-dynamicObj'>    /**
</span>     * Property: dynamicObj
     * {Object} Internal use.
     */
    dynamicObj: null,

<span id='OpenLayers-Control-DynamicMeasure-property-isArea'>    /**
</span>     * Property: isArea
     * {Boolean} Internal use.
     */
    isArea: null,

<span id='OpenLayers-Control-DynamicMeasure-method-initialize'>    /**
</span>     * Constructor: OpenLayers.Control.Measure
     *
     * Parameters:
     * handler - {&lt;OpenLayers.Handler&gt;}
     * options - {Object}
     *
     * Valid options:
     * accuracy - {Integer} Digits measurement accuracy, default is 5.
     * styles - {Object} Alterations of the default styles of the points lines
     *     poligons and labels text, could use keys: &quot;Point&quot;,
     *     &quot;Line&quot;, &quot;Polygon&quot;, &quot;labelSegments&quot;, &quot;labelLength&quot;, &quot;labelArea&quot;.
     * positions - {Object} Alterations of the default position of the labels.
     * handlerOptions - {Object} Used to set non-default properties on the
     *     control's handler. If `layerOptions[&quot;styleMap&quot;]` is set then the
     *     keys: &quot;Point&quot;, &quot;Line&quot; and &quot;Polygon&quot; of the `styles` option
     *     are ignored.
     * layerSegmentsOptions - {Object} Any optional properties to be set on the
     *     layer of &lt;layerSegments&gt; of the lengths of the segments. If
     *     `styleMap` is set then the key &quot;labelSegments&quot; of the `styles` option
     *     is ignored. If set to null the layer does not act.
     * layerLengthOptions - {Object} Any optional properties to be set on the
     *     layer of &lt;layerLength&gt; of the total length. If
     *     `styleMap` is set then the key &quot;labelLength&quot; of the `styles` option
     *     is ignored. If set to null the layer does not act.
     * layerAreaOptions - {Object} Any optional properties to be set on the
     *     layer of &lt;layerArea&gt; of the total area. If
     *     `styleMap` is set then the key &quot;labelArea&quot; of the `styles` option
     *     is ignored. If set to null the layer does not act.
     * layerHeadingOptions - {Object} Any optional properties to be set on the
     *     layer of &lt;layerHeading&gt; of the angle of the segments. If
     *     `styleMap` is set then the key &quot;labelHeading&quot; of the `styles` option
     *     is ignored. If set to null the layer does not act.
     * drawingLayer - {&lt;OpenLayers.Layer.Vector&gt;} Optional drawing layer to
     *     store the drawing when finished.
     * multi - {Boolean} Cast features to multi-part geometries before passing
     *     to the drawing layer
     */
    initialize: function(handler, options) {

        // Manage options
        options = options || {};

        // handlerOptions: persist &amp; multi
        options.handlerOptions = OpenLayers.Util.extend(
            {persist: !options.drawingLayer}, options.handlerOptions
        );
        if (options.drawingLayer &amp;&amp; !('multi' in options.handlerOptions)) {
            options.handlerOptions.multi = options.multi;
        }

        // * styles option
        if (options.drawingLayer) {
            var sketchStyle = options.drawingLayer.styleMap &amp;&amp;
                                 options.drawingLayer.styleMap.styles.temporary;
            if (sketchStyle) {
                options.handlerOptions
                                  .layerOptions = OpenLayers.Util.applyDefaults(
                    options.handlerOptions.layerOptions, {
                        styleMap: new OpenLayers.StyleMap({
                            'default': sketchStyle
                        })
                    }
                );
            }
        }
        var optionsStyles = options.styles || {};
        options.styles = optionsStyles;
        var defaultStyles = OpenLayers.Control.DynamicMeasure.styles;
        // * * styles for handler layer.
        if (!options.handlerOptions.layerOptions ||
            !options.handlerOptions.layerOptions.styleMap) {
            // use the style option for layerOptions of the handler.
            var style = new OpenLayers.Style(null, {rules: [
                new OpenLayers.Rule({symbolizer: {
                    'Point': OpenLayers.Util.applyDefaults(
                                optionsStyles.Point, defaultStyles.Point),
                    'Line': OpenLayers.Util.applyDefaults(
                                optionsStyles.Line, defaultStyles.Line),
                    'Polygon': OpenLayers.Util.applyDefaults(
                                optionsStyles.Polygon, defaultStyles.Polygon)
                }})
            ]});
            options.handlerOptions = options.handlerOptions || {};
            options.handlerOptions.layerOptions =
                                      options.handlerOptions.layerOptions || {};
            options.handlerOptions.layerOptions.styleMap =
                                    new OpenLayers.StyleMap({'default': style});
        }

        // * positions option
        options.positions = OpenLayers.Util.applyDefaults(
            options.positions,
            OpenLayers.Control.DynamicMeasure.positions
        );

        // force some handler options
        options.callbacks = options.callbacks || {};
        if (options.drawingLayer) {
            OpenLayers.Util.applyDefaults(options.callbacks, {
                create: function(vertex, feature) {
                    this.callbackCreate(vertex, feature);
                    this.drawingLayer.events.triggerEvent(
                        'sketchstarted', {vertex: vertex, feature: feature}
                    );
                },
                modify: function(vertex, feature) {
                    this.callbackModify(vertex, feature);
                    this.drawingLayer.events.triggerEvent(
                        'sketchmodified', {vertex: vertex, feature: feature}
                    );
                },
                done: function(geometry) {
                    this.callbackDone(geometry);
                    this.drawFeature(geometry);
                }
            });
        }
        OpenLayers.Util.applyDefaults(options.callbacks, {
            create: this.callbackCreate,
            point: this.callbackPoint,
            cancel: this.callbackCancel,
            done: this.callbackDone,
            modify: this.callbackModify,
            redo: this.callbackRedo,
            undo: this.callbackUndo
        });

        // do a trick with the handler to avoid blue background in freehand.
        var _self = this;
        var oldOnselectstart = document.onselectstart ?
                              document.onselectstart : OpenLayers.Function.True;
        var handlerTuned = OpenLayers.Class(handler, {
            down: function(evt) {
                document.onselectstart = OpenLayers.Function.False;
                return handler.prototype.down.apply(this, arguments);
            },
            up: function(evt) {
                document.onselectstart = oldOnselectstart;
                return handler.prototype.up.apply(this, arguments);
            },
            move: function(evt) {
                if (!this.mouseDown) {
                    document.onselectstart = oldOnselectstart;
                }
                return handler.prototype.move.apply(this, arguments);
            },
            mouseout: function(evt) {
                if (OpenLayers.Util.mouseLeft(evt, this.map.viewPortDiv)) {
                    if (this.mouseDown) {
                        document.onselectstart = oldOnselectstart;
                    }
                }
                return handler.prototype.mouseout.apply(this, arguments);
            },
            finalize: function() {
                document.onselectstart = oldOnselectstart;
                handler.prototype.finalize.apply(this, arguments);
            }
        }, {
            undo: function() {
                var undone = handler.prototype.undo.call(this);
                if (undone) {
                    this.callback('undo',
                                 [this.point.geometry, this.getSketch(), true]);
                }
                return undone;
            },
            redo: function() {
                var redone = handler.prototype.redo.call(this);
                if (redone) {
                    this.callback('redo',
                                 [this.point.geometry, this.getSketch(), true]);
                }
                return redone;
            }
        });
        // ... and call the constructor
        OpenLayers.Control.Measure.prototype.initialize.call(
                                                   this, handlerTuned, options);

        this.isArea = handler.prototype.polygon !== undefined; // duck typing
    },

<span id='OpenLayers-Control-DynamicMeasure-method-destroy'>    /**
</span>     * APIMethod: destroy
     */
    destroy: function() {
        this.deactivate();
        OpenLayers.Control.Measure.prototype.destroy.apply(this, arguments);
    },

<span id='OpenLayers-Control-DynamicMeasure-method-draw'>    /**
</span>     * Method: draw
     * This control does not have HTML component, so this method should
     *     be empty.
     */
    draw: function() {},

<span id='OpenLayers-Control-DynamicMeasure-method-activate'>    /**
</span>     * APIMethod: activate
     */
    activate: function() {
        var response = OpenLayers.Control.Measure.prototype.activate.apply(
                                                               this, arguments);
        if (response) {
            // Create dynamicObj
            this.dynamicObj = {};
            // Create layers
            var _optionsStyles = this.styles || {},
                _defaultStyles = OpenLayers.Control.DynamicMeasure.styles,
                _self = this;
            var _create = function(styleName, initialOptions) {
                if (initialOptions === null) {
                    return null;
                }
                var options = OpenLayers.Util.extend({
                    displayInLayerSwitcher: false,
                    calculateInRange: OpenLayers.Function.True
                    // ?? ,wrapDateLine: this.citeCompliant
                }, initialOptions);
                if (!options.styleMap) {
                    var style = _optionsStyles[styleName];

                    options.styleMap = new OpenLayers.StyleMap({
                        'default': OpenLayers.Util.applyDefaults(style,
                           
                                                      _defaultStyles[styleName])
                    });
                }
                var layer = new OpenLayers.Layer.Vector(
                                   _self.CLASS_NAME + ' ' + styleName, options);
                _self.map.addLayer(layer);
                _self.map.setLayerIndex(layer, 99);
                return layer;
            };
            this.layerSegments =
                            _create('labelSegments', this.layerSegmentsOptions);
            this.layerHeading =
                            _create('labelHeading', this.layerHeadingOptions);
            this.layerLength = _create('labelLength', this.layerLengthOptions);
            if (this.isArea) {
                this.layerArea = _create('labelArea', this.layerAreaOptions);
            }
        }
        return response;
    },

<span id='OpenLayers-Control-DynamicMeasure-method-deactivate'>    /**
</span>     * APIMethod: deactivate
     */
    deactivate: function() {
        var response = OpenLayers.Control.Measure.prototype.deactivate.apply(
                                                               this, arguments);
        if (response) {
            this.layerSegments &amp;&amp; this.layerSegments.destroy();
            this.layerLength &amp;&amp; this.layerLength.destroy();
            this.layerHeading &amp;&amp; this.layerHeading.destroy();
            this.layerArea &amp;&amp; this.layerArea.destroy();
            this.dynamicObj = null;
            this.layerSegments = null;
            this.layerLength = null;
            this.layerHeading = null;
            this.layerArea = null;
        }
        return response;
    },

<span id='OpenLayers-Control-DynamicMeasure-method-setImmediate'>    /**
</span>     * APIMethod: setImmediate
     * Sets the &lt;immediate&gt; property. Changes the activity of immediate
     * measurement.
     */
    setImmediate: function(immediate) {
        this.immediate = immediate;
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackCreate'>    /**
</span>     * Method: callbackCreate
     */
    callbackCreate: function() {
        var dynamicObj = this.dynamicObj;
        dynamicObj.drawing = false;
        dynamicObj.freehand = false;
        dynamicObj.fromIndex = 0;
        dynamicObj.countSegments = 0;
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackCancel'>    /**
</span>     * Method: callbackCancel
     */
    callbackCancel: function() {
        this.destroyLabels();
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackDone'>    /**
</span>     * Method: callbackDone
     * Called when the measurement sketch is done.
     *
     * Parameters:
     * geometry - {&lt;OpenLayers.Geometry&gt;}
     */
    callbackDone: function(geometry) {
        var feature = new OpenLayers.Feature.Vector(geometry);
        this.mapPanel.measureLayer.addFeatures([feature.clone()]);
        var clone = function(e) { return e.clone(); };
        if (this.layerArea) {
            this.mapPanel.measureLayerArea.addFeatures(this.layerArea.features.map(clone));
        }
        this.mapPanel.measureLayerLength.addFeatures(this.layerLength.features.map(clone));
        this.mapPanel.measureLayerSegments.addFeatures(this.layerSegments.features.map(clone));

        this.measureComplete(geometry);
        if (!this.persist) {
            this.destroyLabels();
        }
    },

<span id='OpenLayers-Control-DynamicMeasure-method-drawFeature'>    /**
</span>     * Method: drawFeature
     */
    drawFeature: function(geometry) {
        var feature = new OpenLayers.Feature.Vector(geometry);
        var proceed = this.drawingLayer.events.triggerEvent(
            'sketchcomplete', {feature: feature}
        );
        if (proceed !== false) {
            feature.state = OpenLayers.State.INSERT;
            //this.drawingLayer.addFeatures(this.layerArea.features.map(function(feature) { return feature.clone(); }));
            this.featureAdded &amp;&amp; this.featureAdded(feature);// for compatibility
            this.events.triggerEvent('featureadded', {feature: feature});
        }
    },

<span id='OpenLayers-Control-DynamicMeasure-method-destroyLabels'>    /**
</span>     * Method: callbackCancel
     */
    destroyLabels: function() {
        
        this.layerSegments &amp;&amp; this.layerSegments.destroyFeatures(null, {silent: true});

        this.layerLength &amp;&amp; this.layerLength.destroyFeatures(null, {silent: true});
        
        this.layerHeading &amp;&amp; this.layerHeading.destroyFeatures(
                                                          null, {silent: true});
        this.layerArea &amp;&amp; this.layerArea.destroyFeatures(null, {silent: true});
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackPoint'>    /**
</span>     * Method: callbackPoint
     */
    callbackPoint: function(point, geometry) {
        var dynamicObj = this.dynamicObj;
        if (!dynamicObj.drawing) {
            this.destroyLabels();
        }
        if (!this.handler.freehandMode(this.handler.evt)) {
            dynamicObj.fromIndex = this.handler.getCurrentPointIndex() - 1;
            dynamicObj.freehand = false;
            dynamicObj.countSegments++;
        } else if (!dynamicObj.freehand) {
            // freehand has started
            dynamicObj.fromIndex = this.handler.getCurrentPointIndex() - 1;
            dynamicObj.freehand = true;
            dynamicObj.countSegments++;
        }

        this.measurePartial(point, geometry);
        dynamicObj.drawing = true;
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackUndo'>    /**
</span>     * Method: callbackUndo
     */
    callbackUndo: function(point, feature) {
        var _self = this,
            undoLabel = function(layer) {
                if (layer) {
                    var features = layer.features,
                        lastSegmentIndex = features.length - 1,
                        lastSegment = features[lastSegmentIndex],
                        lastSegmentFromIndex = lastSegment.attributes.from,
                        lastPointIndex = _self.handler.getCurrentPointIndex();
                    if (lastSegmentFromIndex &gt;= lastPointIndex) {
                        var dynamicObj = _self.dynamicObj;
                        layer.destroyFeatures(lastSegment);
                        lastSegment = features[lastSegmentIndex - 1];
                        dynamicObj.fromIndex = lastSegment.attributes.from;
                        dynamicObj.countSegments = features.length;
                    }
                }
            };
        undoLabel(this.layerSegments);
        undoLabel(this.layerHeading);
        this.callbackModify(point, feature, true);
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackRedo'>    /**
</span>     * Method: callbackRedo
     */
    callbackRedo: function(point, feature) {
        var line = this.handler.line.geometry,
            currIndex = this.handler.getCurrentPointIndex();
        var dynamicObj = this.dynamicObj;
        this.showLabelSegment(
            dynamicObj.countSegments,
            dynamicObj.fromIndex,
            line.components.slice(dynamicObj.fromIndex, currIndex)
        );
        dynamicObj.fromIndex = this.handler.getCurrentPointIndex() - 1;
        dynamicObj.countSegments++;
        this.callbackModify(point, feature, true);
    },

<span id='OpenLayers-Control-DynamicMeasure-method-callbackModify'>    /**
</span>     * Method: callbackModify
     */
    callbackModify: function(point, feature, drawing) {
        if (this.immediate) {
            this.measureImmediate(point, feature, drawing);
        }

        var dynamicObj = this.dynamicObj;
        if (dynamicObj.drawing === false) {
           return;
        }

        var line = this.handler.line.geometry,
            currIndex = this.handler.getCurrentPointIndex();
        if (!this.handler.freehandMode(this.handler.evt) &amp;&amp;
                                                          dynamicObj.freehand) {
            // freehand has stopped
            dynamicObj.fromIndex = currIndex - 1;
            dynamicObj.freehand = false;
            dynamicObj.countSegments++;
        }

        // total measure
        var totalLength = this.getBestLength(line);
        if (!totalLength[0]) {
           return;
        }
        var positions = this.positions,
            positionGet = {
            center: function() {
                var center = feature.geometry.getBounds().clone();
                center.extend(point);
                center = center.getCenterLonLat();
                return [center.lon, center.lat];
            },
            initial: function() {
                var initial = line.components[0];
                return [initial.x, initial.y];
            },
            start: function() {
                var start = line.components[dynamicObj.fromIndex];
                return [start.x, start.y];
            },
            middle: function() {
                var start = line.components[dynamicObj.fromIndex];
                return [(start.x + point.x) / 2, (start.y + point.y) / 2];
            },
            end: function() {
                return [point.x, point.y];
            }
        };
        if (this.layerLength) {
            this.showLabel(
                        this.layerLength, 1, 0, totalLength,
                        positionGet[positions['labelLength']](), 1);
        }
        if (this.isArea) {
            if (this.layerArea) {
                this.showLabel(this.layerArea, 1, 0,
                     this.getBestArea(feature.geometry),
                     positionGet[positions['labelArea']](), 1);
            }
            if (this.showLabelSegment(
                      1, 0, [line.components[0], line.components[currIndex]])) {
                dynamicObj.countSegments++;
            }
        }
        this.showLabelSegment(
            dynamicObj.countSegments,
            dynamicObj.fromIndex,
            line.components.slice(dynamicObj.fromIndex, currIndex + 1)
        );
    },

<span id='OpenLayers-Control-DynamicMeasure-method-showLabelSegment'>    /**
</span>     * Function: showLabelSegment
     *
     * Parameters:
     * labelsNumber- {Integer} Number of the labels to be on the label layer.
     * fromIndex - {Integer} Index of the last point on the measured feature.
     * points - Array({&lt;OpenLayers.Geometry.Point&gt;})
     *
     * Returns:
     * {Boolean}
     */
    showLabelSegment: function(labelsNumber, fromIndex, _points) {
        var layerSegments = this.layerSegments,
            layerHeading = this.layerHeading;
        if (!layerSegments &amp;&amp; !layerHeading) {
            return false;
        }
        // clone points
        var points = [],
            pointsLen = _points.length;
        for (var i = 0; i &lt; pointsLen; i++) {
            points.push(_points[i].clone());
        }
        var from = points[0],
            to = points[pointsLen - 1],
            segmentLength =
                 this.getBestLength(new OpenLayers.Geometry.LineString(points)),
            positions = this.positions,
            positionGet = {
                start: function() {
                    return [from.x, from.y];
                },
                middle: function() {
                    return [(from.x + to.x) / 2, (from.y + to.y) / 2];
                },
                end: function() {
                    return [to.x, to.y];
                }
            },
            created = false;
        if (layerSegments) {
            created = this.showLabel(layerSegments, labelsNumber, fromIndex,
                            segmentLength,
                            positionGet[positions['labelSegments']](),
                            this.maxSegments);
        }
        if (layerHeading &amp;&amp; segmentLength[0] &gt; 0) {
            var heading = Math.atan2(to.y - from.y, to.x - from.x),
                bearing = 90 - heading * 180 / Math.PI;
            if (bearing &lt; 0) {
                bearing += 360;
            }
            created = created || this.showLabel(layerHeading,
                            labelsNumber, fromIndex,
                            [bearing, '°'],
                            positionGet[positions['labelHeading']](),
                            this.maxHeadings);
        }
        return created;
    },

<span id='OpenLayers-Control-DynamicMeasure-method-showLabel'>    /**
</span>     * Function: showLabel
     *
     * Parameters:
     * layer - {&lt;OpenLayers.Layer.Vector&gt;} Layer of the labels.
     * labelsNumber- {Integer} Number of the labels to be on the label layer.
     * fromIndex - {Integer} Index of the last point on the measured feature.
     * measure - Array({Float|String}) Measure provided by OL Measure control.
     * points - Array({Fload}) Array of x and y of the point to draw the label.
     * maxSegments - {Integer|Null} Maximum number of visible segments measures
     *
     * Returns:
     * {Boolean}
     */
    showLabel: function(
                     layer, labelsNumber, fromIndex, measure, xy, maxSegments) {
        var featureLabel, featureAux,
            features = layer.features;
        if (features.length &lt; labelsNumber) {
        // add a label
            if (measure[0] === 0) {
                return false;
            }
            featureLabel = new OpenLayers.Feature.Vector(
                new OpenLayers.Geometry.Point(xy[0], xy[1]),
                {from: fromIndex}
            );
            this.setMesureAttributes(featureLabel.attributes, measure);
            layer.addFeatures([featureLabel]);
            if (maxSegments !== null) {
                var hide = (features.length - maxSegments) - 1;
                if (hide &gt;= 0) {
                    featureAux = features[hide];
                    featureAux.style = {display: 'none'};
                    layer.drawFeature(featureAux);
                }
            }
            return true;
        } else {
        // update a label
            featureLabel = features[labelsNumber - 1];
            var geometry = featureLabel.geometry;
            geometry.x = xy[0];
            geometry.y = xy[1];
            geometry.clearBounds();
            this.setMesureAttributes(featureLabel.attributes, measure);
            layer.drawFeature(featureLabel);
            if (maxSegments !== null) {
                var show = (features.length - maxSegments);
                if (show &gt;= 0) {
                    featureAux = features[show];
                    if (featureAux.style) {
                        delete featureAux.style;
                        layer.drawFeature(featureAux);
                    }
                }
            }
            return false;
        }
    },

<span id='OpenLayers-Control-DynamicMeasure-method-setMesureAttributes'>    /**
</span>     * Method: setMesureAttributes
     * Format measure[0] with digits of &lt;accuracy&gt;. Could internationalize the
     *     format customizing &lt;OpenLayers.Number.thousandsSeparator&gt; and
     *     &lt;OpenLayers.Number.decimalSeparator&gt;
     *
     * Parameters:
     * attributes - {object} Target attributes.
     * measure - Array({*})
     */
    setMesureAttributes: function(attributes, measure) {
        attributes.measure = OpenLayers.Number.format(measure[0].toFixed(2), null);
                           //Number(measure[0].toPrecision(this.accuracy)), null);
        attributes.units = measure[1];
    },

    CLASS_NAME: 'OpenLayers.Control.DynamicMeasure'
});

<span id='OpenLayers-Control-DynamicMeasure-property-styles'>/**
</span> * Constant: OpenLayers.Control.DynamicMeasure.styles
 * Contains the keys: &quot;Point&quot;, &quot;Line&quot;, &quot;Polygon&quot;,
 *     &quot;labelSegments&quot;, &quot;labelHeading&quot;, &quot;labelLength&quot; and
 *     &quot;labelArea&quot; as a objects with style keys.
 */
OpenLayers.Control.DynamicMeasure.styles = {
    'Point': {
        pointRadius: 4,
        graphicName: 'square',
        fillColor: 'white',
        fillOpacity: 1,
        strokeWidth: 1,
        strokeOpacity: 1,
        strokeColor: '#333333'
    },
    'Line': {
        strokeWidth: 2,
        strokeOpacity: 1,
        strokeColor: '#666666',
        strokeDashstyle: 'dash'
    },
    'Polygon': {
        strokeWidth: 2,
        strokeOpacity: 1,
        strokeColor: '#666666',
        strokeDashstyle: 'solid',
        fillColor: 'white',
        fillOpacity: 0.3
    },
    labelSegments: {
        label: '${measure} ${units}',
        fontSize: '12px',
        fontColor: '#800517',
        fontFamily: 'Verdana',
        labelOutlineColor: '#eeeeee',
        labelAlign: 'cm',
        labelOutlineWidth: 2
    },
    labelLength: {
        label: '${measure} ${units}\n',
        fontSize: '12px',
        fontWeight: 'bold',
        fontColor: '#800517',
        fontFamily: 'Verdana',
        labelOutlineColor: '#eeeeee',
        labelAlign: 'lb',
        labelOutlineWidth: 3
    },
    labelArea: {
        label: '${measure}\n${units}²\n',
        fontSize: '11px',
        fontWeight: 'bold',
        fontColor: '#800517',
        fontFamily: 'Verdana',
        labelOutlineColor: '#dddddd',
        labelAlign: 'cm',
        labelOutlineWidth: 3
    },
    labelHeading: {
        label: '${measure} ${units}',
        fontSize: '11px',
        fontColor: '#800517',
        fontFamily: 'Verdana',
        labelOutlineColor: '#dddddd',
        labelAlign: 'cm',
        labelOutlineWidth: 3
    }
};

<span id='OpenLayers-Control-DynamicMeasure-property-positions'>/**
</span> * Constant: OpenLayers.Control.DynamicMeasure.positions
 * Contains the keys: &quot;labelSegments&quot;, &quot;labelHeading&quot;,
 *     &quot;labelLength&quot; and &quot;labelArea&quot; as a strings with values 'start',
 *     'middle' and 'end' allowed for all keys (refered of last segment) and
 *     'center' and 'initial' (refered of the measured feature and only allowed
 *     for &quot;labelLength&quot; and &quot;labelArea&quot; keys)
 */
OpenLayers.Control.DynamicMeasure.positions = {
    labelSegments: 'middle',
    labelLength: 'end',
    labelArea: 'center',
    labelHeading: 'start'
};
</pre>
</body>
</html>
