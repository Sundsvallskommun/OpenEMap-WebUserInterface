<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*    
    Copyright (C) 2014 Härnösands kommun

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/
<span id='OpenEMap-view-Map'>/**
</span> * 
 */
Ext.define('OpenEMap.view.Map' ,{
    extend: 'GeoExt.panel.Map',
<span id='OpenEMap-view-Map-cfg-border'>    border: false,
</span><span id='OpenEMap-view-Map-property-anchor'>    anchor: '100% 100%',
</span><span id='OpenEMap-view-Map-method-constructor'>    constructor: function(config) {
</span>        this.initDefaultLayers(config.config);
        
        var printProvider = Ext.create('GeoExt.data.MapfishPrintProvider', {
            url: OpenEMap.basePathMapFish,
            autoLoad: true,
            timeout: 60*1000,
            listeners: {
                /*&quot;loadcapabilities&quot;: function(printProvider, capabilities) {
                    // NOTE: need to override to test locally...
                    capabilities.createURL = &quot;/print/pdf/create.json&quot;;
                },*/
                &quot;encodelayer&quot;: function(printProvider, layer, encodedLayer) {
                    if (encodedLayer &amp;&amp; encodedLayer.baseURL) {
                        encodedLayer.baseURL = encodedLayer.baseURL.replace('gwc/service/', '');
                    }
                }/*,
                &quot;beforedownload&quot;: function(printProvider, url) {
                    console.log(&quot;beforedownload&quot;);
                }*/
            }
        });
        
        var printExtent = Ext.create('GeoExt.plugins.PrintExtent', {
            printProvider: printProvider
        });
        
        this.encode = function(layout) {
            var page = printExtent.addPage();
            if (layout) {
                var record = printProvider.layouts.findRecord('name', layout);
                printProvider.setLayout(record);
            }
            var json = printProvider.encode(printExtent.map, printExtent.pages);
            printExtent.removePage(page);
            return json;
        }
        
        printProvider.encode = function(map, pages, options) {
            if(map instanceof GeoExt.MapPanel) {
                map = map.map;
            }
            pages = pages instanceof Array ? pages : [pages];
            options = options || {};
            if(this.fireEvent(&quot;beforeprint&quot;, this, map, pages, options) === false) {
                return;
            }

            var jsonData = Ext.apply({
                units: map.getUnits(),
                srs: map.baseLayer.projection.getCode(),
                layout: this.layout.get(&quot;name&quot;),
                dpi: this.dpi.get(&quot;value&quot;)
            }, this.customParams);

            var pagesLayer = pages[0].feature.layer;
            var encodedLayers = [];

            // ensure that the baseLayer is the first one in the drawingLayer encoded list
            var layers = map.layers.concat();

            Ext.Array.remove(layers, map.baseLayer);
            Ext.Array.insert(layers, 0, [map.baseLayer]);

            Ext.each(layers, function(layer){
                if(layer !== pagesLayer &amp;&amp; layer.getVisibility() === true) {
                    var enc = this.encodeLayer(layer);
                    enc &amp;&amp; encodedLayers.push(enc);
                }
            }, this);
            jsonData.layers = encodedLayers;

            var encodedPages = [];
            Ext.each(pages, function(page) {

                encodedPages.push(Ext.apply({
                    center: [page.center.lon, page.center.lat],
                    scale: page.scale.get(&quot;value&quot;),
                    rotation: page.rotation
                }, page.customParams));
            }, this);
            jsonData.pages = encodedPages;

            if (options.overview) {
                var encodedOverviewLayers = [];
                Ext.each(options.overview.layers, function(layer) {
                    var enc = this.encodeLayer(layer);
                    enc &amp;&amp; encodedOverviewLayers.push(enc);
                }, this);
                jsonData.overviewLayers = encodedOverviewLayers;
            }

            if(options.legend &amp;&amp; !(this.fireEvent(&quot;beforeencodelegend&quot;, this, jsonData, options.legend) === false)) {
                var legend = options.legend;
                var rendered = legend.rendered;
                if (!rendered) {
                    legend = legend.cloneConfig({
                        renderTo: document.body,
                        hidden: true
                    });
                }
                var encodedLegends = [];
                legend.items &amp;&amp; legend.items.each(function(cmp) {
                    if(!cmp.hidden) {
                        var encFn = this.encoders.legends[cmp.getXType()];
                        // MapFish Print doesn't currently support per-page
                        // legends, so we use the scale of the first page.
                        encodedLegends = encodedLegends.concat(
                            encFn.call(this, cmp, jsonData.pages[0].scale));
                    }
                }, this);
                if (!rendered) {
                    legend.destroy();
                }
                jsonData.legends = encodedLegends;
            }
            
            return jsonData;
        }
        
        config.plugins = [printExtent];
        
        this.callParent(arguments);
                
        this.layers.add(this.searchLayer);
        this.layers.add(this.drawLayer);
        this.layers.add(this.measureLayer);
        this.layers.add(this.measureLayerArea);
        this.layers.add(this.measureLayerLength);
        this.layers.add(this.measureLayerSegments);
        
        this.map.setLayerIndex(this.measureLayer, 98);
        this.map.setLayerIndex(this.measureLayerArea, 98);
        this.map.setLayerIndex(this.measureLayerLength, 98);
        this.map.setLayerIndex(this.measureLayerSegments, 98);
        
        this.selectControl = new OpenLayers.Control.SelectFeature(this.drawLayer);
        this.map.addControl(this.selectControl);
    },
<span id='OpenEMap-view-Map-method-unselectAll'>    unselectAll: function() {
</span>        this.drawLayer.selectedFeatures.forEach(function(feature) {
            this.selectControl.unselect(feature);
        }, this);
    },
<span id='OpenEMap-view-Map-method-parseStyle'>    parseStyle: function(style) {
</span>        var template = {
                &quot;Point&quot;: {
                    pointRadius: 4,
                    graphicName: &quot;square&quot;,
                    fillColor: &quot;#e8ffee&quot;,
                    fillOpacity: 0.9,
                    strokeWidth: 1,
                    strokeOpacity: 1,
                    strokeColor: &quot;#29bf4c&quot;
                },
                &quot;Line&quot;: {
                    strokeWidth: 3,
                    strokeColor: &quot;#29bf4c&quot;,
                    strokeOpacity: 1
                },
                &quot;Polygon&quot;: {
                    strokeWidth: 3,
                    strokeOpacity: 1,
                    strokeColor: &quot;#29bf4c&quot;,
                    fillColor: &quot;#e8ffee&quot;,
                    fillOpacity: 0.9
                }
            };
        
        var createSymbolizer = function(style) {
            var clone = Ext.clone(template);
            if (style[&quot;Point&quot;]) {
                Ext.apply(clone[&quot;Point&quot;], style[&quot;Point&quot;]);
                Ext.apply(clone[&quot;Line&quot;], style[&quot;Line&quot;]);
                Ext.apply(clone[&quot;Polygon&quot;], style[&quot;Polygon&quot;]);
                if (style.labelSegments){
                    Ext.apply(clone[&quot;labelSegments&quot;], style[&quot;labelSegments&quot;]);
                }
                if (style.labelLength){
                    Ext.apply(clone[&quot;labelLength&quot;], style[&quot;labelLength&quot;]);
                }
            } else {
                Ext.apply(clone[&quot;Point&quot;], style);
                Ext.apply(clone[&quot;Line&quot;], style);
                Ext.apply(clone[&quot;Polygon&quot;], style);
            }
            return clone;
        };
        
        var defaultStyle = new OpenLayers.Style(null, {rules: [ new OpenLayers.Rule({symbolizer: template})]});
        var selectStyle;
        var temporaryStyle;
        var measureStyle;
        if (style) {
            if (style[&quot;default&quot;]) {
                defaultStyle = createSymbolizer(style[&quot;default&quot;]);
                defaultStyle = new OpenLayers.Style(null, {rules: [ new OpenLayers.Rule({symbolizer: defaultStyle})]});
            }
            if (style[&quot;select&quot;]) {
                selectStyle = createSymbolizer(style[&quot;select&quot;]);
                selectStyle = new OpenLayers.Style(null, {rules: [ new OpenLayers.Rule({symbolizer: selectStyle})]});
            }
            if (style[&quot;temporary&quot;]) {
                temporaryStyle = createSymbolizer(style[&quot;temporary&quot;]);
                temporaryStyle = new OpenLayers.Style(null, {rules: [ new OpenLayers.Rule({symbolizer: temporaryStyle})]});
            }
            if (style[&quot;labelLength&quot;]){
                measureStyle = createSymbolizer(style);
                measureStyle = new OpenLayers.Style(null, {rules: [new OpenLayers.Rule({symbolizer: measureStyle}) ] });

            }
            if (!style[&quot;default&quot;]) {
                defaultStyle = createSymbolizer(style);
                defaultStyle = new OpenLayers.Style(null, {rules: [ new OpenLayers.Rule({symbolizer: defaultStyle})]});
            }
        }
        
        var map = {
            &quot;default&quot;: defaultStyle
        };
        if (selectStyle) {
            map[&quot;select&quot;] = selectStyle;
        }
        if (temporaryStyle) {
            map[&quot;temporary&quot;] = temporaryStyle;
        }

        if (measureStyle){
            map[&quot;default&quot;] = measureStyle;
        }

        var styleMap = new OpenLayers.StyleMap(map);
        
        return styleMap;
    },
<span id='OpenEMap-view-Map-method-initDefaultLayers'>    initDefaultLayers: function(config) {
</span>        if (!config.drawStyle) {
            config.drawStyle = {
                    &quot;default&quot;: {
                        &quot;Point&quot;: {
                            pointRadius: 4,
                            graphicName: &quot;square&quot;,
                            fillColor: &quot;#ffffff&quot;,
                            fillOpacity: 1,
                            strokeWidth: 1,
                            strokeOpacity: 1,
                            strokeColor: &quot;#2969bf&quot;
                        },
                        &quot;Line&quot;: {
                            strokeWidth: 3,
                            strokeColor: &quot;#2969bf&quot;,
                            strokeOpacity: 1
                        },
                        &quot;Polygon&quot;: {
                            strokeWidth: 3,
                            strokeOpacity: 1,
                            strokeColor: &quot;#2969bf&quot;,
                            fillOpacity: 0
                        }
                    },
                    &quot;select&quot;: {
                        strokeWidth: 3,
                        strokeOpacity: 1,
                        fillColor: &quot;#deecff&quot;,
                        fillOpacity: 0.9,
                        strokeColor: &quot;#2969bf&quot;
                    },
                    &quot;temporary&quot;: {
                        strokeWidth: 3,
                        strokeOpacity: 0.75,
                        fillColor: &quot;#ff00ff&quot;,
                        fillOpacity: 0,
                        strokeColor: &quot;#ff00ff&quot;
                    }
            };
        }
        
        this.drawLayer = new OpenLayers.Layer.Vector('Drawings', {
            displayInLayerSwitcher: false,
            styleMap: this.parseStyle(config.drawStyle)
        });
        
        if (config.autoClearDrawLayer) {
            this.drawLayer.events.register('beforefeatureadded', this, function() {
                this.drawLayer.destroyFeatures();
            });
        }
        
        function onFeatureadded(e) {
            var feature = e.feature;
            this.selectControl.select(feature);
        }
        
        function onBeforefeaturemodified(e) {
            var feature = e.feature;
            this.selectControl.select(feature);
        }
        
        function onAfterfeaturemodified(e) {
            var feature = e.feature;
            //this.selectControl.unselect(feature);
        }
        
        //this.drawLayer.events.register('featureadded', this, onFeatureadded);
        this.drawLayer.events.register('beforefeaturemodified', this, onBeforefeaturemodified);
        this.drawLayer.events.register('afterfeaturemodified', this, onAfterfeaturemodified);
        
        var searchStyle = {
                &quot;Point&quot;: {
                    pointRadius: 4,
                    graphicName: &quot;square&quot;,
                    fillColor: &quot;#ffffff&quot;,
                    fillOpacity: 1,
                    strokeWidth: 1,
                    strokeOpacity: 1,
                    strokeColor: &quot;#2969bf&quot;
                },
                &quot;Line&quot;: {
                    strokeWidth: 3,
                    strokeColor: &quot;#2969bf&quot;,
                    strokeOpacity: 1
                },
                &quot;Polygon&quot;: {
                    strokeDashstyle: 'dot',
                    strokeWidth: 3,
                    strokeOpacity: 1,
                    strokeColor: &quot;#f58d1e&quot;,
                    fillOpacity: 0
                }
        };
        
        this.searchLayer = new OpenLayers.Layer.Vector('Searchresult', {
            displayInLayerSwitcher: false,
            styleMap: this.parseStyle(searchStyle)
        });
        
        var defaultStyles = OpenLayers.Control.DynamicMeasure.styles;
        
        var style = new OpenLayers.Style(null, {rules: [
            new OpenLayers.Rule({symbolizer: {
                'Point': defaultStyles.Point,
                'Line': defaultStyles.Line,
                'Polygon': defaultStyles.Polygon
            }})
        ]});
        var styleMap = new OpenLayers.StyleMap({&quot;default&quot;: style});
        
        var createStyleMap = function(name) {
            return new OpenLayers.StyleMap({ 'default': OpenLayers.Util.applyDefaults(null, defaultStyles[name])});
        };
        
        this.measureLayer = new OpenLayers.Layer.Vector('MeasureLayer', {
            displayInLayerSwitcher: false,
            styleMap: styleMap
        });
        
        this.measureLayerArea = new OpenLayers.Layer.Vector('MeasureLayerArea', {
            displayInLayerSwitcher: false,
            styleMap: createStyleMap('labelArea')
        });
        
        this.measureLayerSegments = new OpenLayers.Layer.Vector('MeasureLayerSegments', {
            displayInLayerSwitcher: false,
            styleMap: createStyleMap('labelSegments')
        });
        
        this.measureLayerLength = new OpenLayers.Layer.Vector('MeasureLayerLength', {
            displayInLayerSwitcher: false,
            styleMap: createStyleMap('labelLength')
        });
    },
<span id='OpenEMap-view-Map-method-setInitialExtent'>    setInitialExtent: function() {
</span>        var map = this.map;
        if (!map.getCenter()) {
            if (this.center || this.zoom ) {
                // center and/or zoom?
                map.setCenter(this.center, this.zoom);
            } else if (this.extent instanceof OpenLayers.Bounds) {
                // extent
                map.zoomToExtent(this.extent, false);
            }else {
                map.zoomToMaxExtent();
            }
        }
    }
});
</pre>
</body>
</html>
